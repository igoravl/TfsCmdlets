using System.Collections.Generic;
using TfsCmdlets.Models;
using TfsCmdlets.Services;

#if NET471_OR_GREATER
using System;
using System.Linq;
using System.Threading;
using Microsoft.TeamFoundation.Client;
using Microsoft.TeamFoundation.Framework.Client;
using Microsoft.TeamFoundation.Framework.Common;
#endif

namespace TfsCmdlets.Cmdlets.TeamProjectCollection
{
    [Controller(typeof(Connection))]
    internal class TeamProjectCollectionController : CollectionLevelController<Connection>
    {

#if NET471_OR_GREATER
        private Connection Connection { get; }
#endif

        private ICurrentConnections CurrentConnections { get; set; }

        protected override IEnumerable<Connection> DoGetItems(ParameterDictionary parameters)
        {
            var current = parameters.Get<bool>("Current");

            if (current)
            {
                yield return CurrentConnections.Collection;
                yield break;
            }

            yield return Collection;
        }

        protected override Connection DoConnectItem(ParameterDictionary parameters)
        {
            Collection.Connect();

            var srv = Collection.ConfigurationServer;

            CurrentConnections.Set(srv, Collection);

            Logger.Log($"Connected to {Collection.Uri}, ID {Collection.ServerId}, as '{Collection.AuthorizedIdentity.DisplayName}'");

            return Collection;
        }

        protected override void DoDisconnectItem(ParameterDictionary parameters)
        {
            CurrentConnections.Set(
                CurrentConnections.Server,
                null
            );
        }

        protected override Connection DoNewItem(ParameterDictionary parameters)
        {
        }

        protected override void DoDismountItem(ParameterDictionary parameters)
        {
#if NET471_OR_GREATER
            var tpc = Collection;
            var srv = tpc.ConfigurationServer;
            var reason = parameters.Get<string>(nameof(DismountTeamProjectCollection.Reason));
            var timeout = parameters.Get<TimeSpan>(nameof(DismountTeamProjectCollection.Timeout));

            if (!PowerShell.ShouldProcess($"Server '{srv.Uri}'", $"Detach collection '{tpc.DisplayName}'")) return;

            var tpcService = srv.GetService<Microsoft.TeamFoundation.Framework.Client.ITeamProjectCollectionService>();
            var collectionInfo = tpcService.GetCollection(tpc.InnerConnection.InstanceId);

            var tpcJob = tpcService.QueueDetachCollection(collectionInfo, null, reason, out var connectionString);
            collectionInfo = tpcService.WaitForCollectionServicingToComplete(tpcJob, timeout);

            PowerShell.WriteObject(connectionString);
#endif
        }

        protected override void DoMountItem(ParameterDictionary parameters)
        {
#if NET471_OR_GREATER
            var configServer = (TfsConfigurationServer)Connection;
            var tpcService = configServer.GetService<ITeamProjectCollectionService>();

            var collectionName = parameters.Get<string>(nameof(MountTeamProjectCollection.Collection));
            var servicingTokens = new Dictionary<string, string>();
            var databaseServer = parameters.Get<string>(nameof(MountTeamProjectCollection.DatabaseServer));
            var databaseName = parameters.Get<string>(nameof(MountTeamProjectCollection.DatabaseName));
            var description = parameters.Get<string>(nameof(MountTeamProjectCollection.Description));
            var connectionString = parameters.Get<string>(nameof(MountTeamProjectCollection.ConnectionString));
            var timeout = parameters.Get<TimeSpan>(nameof(MountTeamProjectCollection.Timeout));
            var clone = parameters.Get<bool>(nameof(MountTeamProjectCollection.Clone));

            if (!string.IsNullOrEmpty(databaseServer))
            {
                servicingTokens["CollectionDatabaseName"] = databaseName;
                connectionString = $"Data source={databaseServer}; Integrated Security=true; Initial Catalog={databaseName}";
            }

            var tpcJob = tpcService.QueueAttachCollection(
                connectionString,
                servicingTokens, clone,
                collectionName,
                description,
                $"~/{Collection}/");

            var collection = tpcService.WaitForCollectionServicingToComplete(tpcJob, timeout);

            PowerShell.WriteObject(GetItem(new { Collection = collectionName }));
#endif
        }

#if NET471_OR_GREATER
        public TeamProjectCollectionController(
            Connection server,
            ICurrentConnections currentConnections,
            Connection collection,
            ILogger logger,
            IParameterManager parameterManager,
            IPowerShellService powerShell)
            : base(collection, logger, parameterManager, powerShell)
        {
            Connection = server;
            CurrentConnections = currentConnections;
        }
#else
        public TeamProjectCollectionController(
            ICurrentConnections currentConnections,
            Connection collection,
            ILogger logger,
            IParameterManager parameterManager,
            IPowerShellService powerShell)
            : base(collection, logger, parameterManager, powerShell)
        {
            CurrentConnections = currentConnections;
        }
#endif
    }
}