using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TfsCmdlets.SourceGenerators
{
    [Generator]
    public class CmdletGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new CmdletSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is CmdletSyntaxReceiver syntaxReceiver)) return;

            //if(!Debugger.IsAttached) Debugger.Launch();

            foreach (var cmdlet in syntaxReceiver.Cmdlets)
            {
                var settings = GetSettings(cmdlet);
                var props = new StringBuilder();

                // Add verb-specific properties

                switch (settings.Verb)
                {
                    case "Rename":
                        {
                            props.Append(@"
        /// <summary>
        /// HELP_PARAM_NEWNAME
        /// </summary>
        [Parameter(Position = 1, Mandatory = true)]
        public string NewName { get; set; }

        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter]
        public SwitchParameter Passthru { get; set; }
");
                            break;
                        }
                    case "New":
                    case "Set":
                        {
                            props.Append(@"
        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter]
        public SwitchParameter Passthru { get; set; }
");
                            break;
                        }
                }

                // Add scope-specific properties

                props.Append(GetPropertyFor(cmdlet, CmdletScope.Team, settings));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Project, settings));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Collection, settings));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Server, settings));
                props.Append(GetConnectProperties(cmdlet, settings));

                context.AddSource($"{cmdlet.FullName()}.cs", SourceText.From($@"/*
Generated by: [TfsCmdlets.SourceGenerators.CmdletGenerator]
Class name  : {cmdlet.FullName()}
Verb        : {settings.Verb}
SkipCodeGen : {settings.SkipAutoProperties}
*/

using System.Security;
using System.Management.Automation;
using System.Composition;
using TfsCmdlets.Services;

// ReSharper disable once CheckNamespace
namespace {cmdlet.FullNamespace()}
{{
  public partial class {cmdlet.Name}: CmdletBase
  {{
{(settings.SkipAutoProperties ? string.Empty : props.ToString())}
  }}
}}
",
                    Encoding.UTF8));
            }
        }

        private string GetConnectProperties(INamedTypeSymbol cmdlet, CmdletSettings settings)
        {
            if (!settings.Verb.Equals("Connect", StringComparison.OrdinalIgnoreCase)) return string.Empty;

            return @"
        /// <summary>
        /// HELP_PARAM_CACHED_CREDENTIAL
        /// </summary>
        [Parameter(ParameterSetName = ""Cached credentials"", Mandatory = true)]
        public SwitchParameter Cached { get; set; }

        /// <summary>
        /// HELP_PARAM_USER_NAME
        /// </summary>
        [Parameter(ParameterSetName = ""User name and password"", Mandatory = true, Position = 1)]
        public string UserName { get; set; }

        /// <summary>
        /// HELP_PARAM_PASSWORD
        /// </summary>
        [Parameter(ParameterSetName = ""User name and password"", Position = 2)]
        public SecureString Password { get; set; }

        /// <summary>
        /// HELP_PARAM_CREDENTIAL
        /// </summary>
        [Parameter(ParameterSetName = ""Credential object"", Mandatory = true)]
        [ValidateNotNull]
        public object Credential { get; set; }

        /// <summary>
        /// HELP_PARAM_PERSONAL_ACCESS_TOKEN
        /// </summary>
        [Parameter(ParameterSetName = ""Personal Access Token"", Mandatory = true)]
        [Alias(""Pat"")]
        public string PersonalAccessToken { get; set; }

        /// <summary>
        /// HELP_PARAM_INTERACTIVE
        /// </summary>
        [Parameter(ParameterSetName = ""Prompt for credential"")]
        public SwitchParameter Interactive { get; set; }

        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter]
        public SwitchParameter Passthru { get; set; }
";
        }

        private CmdletSettings GetSettings(INamedTypeSymbol cmdlet)
        {
            return new CmdletSettings
            {
                Verb = GetAttributeConstructorValue<string>(cmdlet, "CmdletAttribute"),
                Scope = GetAttributeConstructorValue<CmdletScope>(cmdlet, "TfsCmdletAttribute"),
                SkipAutoProperties = GetAttributeNamedValue(cmdlet, "TfsCmdletAttribute", "SkipAutoProperties"),
                DesktopOnly = GetAttributeNamedValue(cmdlet, "TfsCmdletAttribute", "DesktopOnly"),
                HostedOnly = GetAttributeNamedValue(cmdlet, "TfsCmdletAttribute", "HostedOnly"),
                RequiresVersion = GetAttributeNamedValue<int>(cmdlet, "TfsCmdletAttribute", "RequiresVersion"),
                PipelineProperty = GetAttributeNamedValue<string>(cmdlet, "TfsCmdletAttribute", "PipelineProperty")
            };
        }

        private string GetPropertyFor(ISymbol cmdlet, CmdletScope currentScope, CmdletSettings settings)
        {
            int.TryParse(cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals("TfsCmdletAttribute"))?
                .ConstructorArguments[0].Value.ToString(), out var cmdletScope);

            if (cmdletScope < (int)currentScope) return string.Empty;

            var scopeName = currentScope.ToString();
            var isPipeline = IsPipelineProperty(scopeName, currentScope, settings);
            var valueFromPipeline = isPipeline ? "(ValueFromPipeline=true)" : string.Empty;
            var alias = scopeName.Equals("Collection")? ", Alias(\"Organization\")" : string.Empty;

            return $@"
        /// <summary>
        /// HELP_PARAM_{scopeName.ToUpper()}
        /// </summary>
        [Parameter{valueFromPipeline}{alias}]
        public object {scopeName} {{ get; set; }}
";
        }

        private bool IsPipelineProperty(string propertyName, CmdletScope currentScope, CmdletSettings settings)
        {
            if(!string.IsNullOrEmpty(settings.PipelineProperty))
            {
                return propertyName.Equals(settings.PipelineProperty, StringComparison.OrdinalIgnoreCase);
            }

            return ((settings.Verb.Equals("Get") || settings.Verb.StartsWith("Connect")) || ((int)settings.Scope == (int)currentScope));
        }

        private T GetAttributeConstructorValue<T>(INamedTypeSymbol cmdlet, string attributeName, int argumentPosition = 0)
        {
            var attr = cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals(attributeName));

            if (attr == null) return default(T);

            var arg = attr.ConstructorArguments[argumentPosition];

            return (T)arg.Value;
        }

        private T GetAttributeNamedValue<T>(INamedTypeSymbol cmdlet, string attributeName, string argumentName)
        {
            var attr = cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals(attributeName));

            if (attr == null) return default(T);

            var arg = attr.NamedArguments.FirstOrDefault(a => a.Key.Equals(argumentName));

            return (T)(arg.Value.Value ?? default(T));
        }

        private bool GetAttributeNamedValue(INamedTypeSymbol cmdlet, string attributeName, string argumentName, bool defaultValue = false)
        {
            var attr = cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals(attributeName));

            if (attr == null) return defaultValue;

            var arg = attr.NamedArguments.FirstOrDefault(a => a.Key.Equals(argumentName));

            return (arg.Value.Value?.ToString() ?? string.Empty).Equals("True", StringComparison.OrdinalIgnoreCase);
        }

        internal class CmdletSyntaxReceiver : ISyntaxContextReceiver
        {
            internal List<INamedTypeSymbol> Cmdlets { get; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                var node = context.Node;

                if (!(node is ClassDeclarationSyntax cds)) return;

                var type = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;

                if (!type.GetAttributes().Any(attr1 => attr1.AttributeClass.Name.Equals("CmdletAttribute"))) return;

                Cmdlets.Add(type);
            }
        }

        [Flags]
        private enum CmdletScope
        {
            None = 0,
            Server = 1,
            Collection = 2,
            Project = 3,
            Team = 4
        }

        private class CmdletSettings
        {
            internal string Verb { get; set; }
            internal CmdletScope Scope { get; set; }
            internal bool SkipAutoProperties { get; set; }
            internal bool DesktopOnly { get; set; }
            internal bool HostedOnly { get; set; }
            internal int RequiresVersion { get; set; }
            internal string PipelineProperty { get; set; }
        }

    }
}