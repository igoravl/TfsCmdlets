using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TfsCmdlets.SourceGenerators
{
    [Generator]
    public class CmdletGenerator : ISourceGenerator
    {
        private static readonly string[] _scopeNames = new[]{
            "ConfigurationServer", "TeamProjectCollection", "TeamProject", "Team" };
        private static readonly string[] _credentialParameterSetNames = new[]{
            "Cached credentials", "User name and password", "Credential object", "Personal Access Token", "Prompt for credential" };

        private readonly List<(Predicate<CmdletInfo>, Func<CmdletInfo, string>)> _generators =
            new List<(Predicate<CmdletInfo>, Func<CmdletInfo, string>)>();

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new CmdletSyntaxReceiver());
            RegisterGenerators();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is CmdletSyntaxReceiver syntaxReceiver)) return;

            foreach (var type in syntaxReceiver.Cmdlets)
            {
                var cmdlet = new CmdletInfo(type);
                var props = new StringBuilder();

                if (!cmdlet.SkipAutoProperties)
                {
                    foreach (var (condition, generator) in _generators)
                    {
                        if (condition(cmdlet)) props.Append(generator(cmdlet));
                    }
                }

                var cmdletAttribute = GenerateCmdletAttribute(cmdlet);
                var outputTypeAttribute = GenerateOutputTypeAttribute(cmdlet);
                var sourceText = SourceText.From($@"/*
Generated by: [TfsCmdlets.SourceGenerators.CmdletGenerator]
Class name  : {type.FullName()}
Verb        : {cmdlet.Verb}
Noun        : {cmdlet.Noun}
SkipCodeGen : {cmdlet.SkipAutoProperties}
*/

using System.Security;
using System.Management.Automation;
using System.Composition;
using TfsCmdlets.Services;

// ReSharper disable once CheckNamespace
namespace {type.FullNamespace()}
{{
  {cmdletAttribute}{outputTypeAttribute}
  public partial class {type.Name}: CmdletBase
  {{
{props}
  }}
}}
",
                    Encoding.UTF8);

                context.AddSource($"{type.FullName()}.cs", sourceText);
            }
        }

        private void RegisterGenerators()
        {
            // Basic properties
            _generators.Add(((cmdlet) => cmdlet.Verb == "Rename", GenerateNewNameProperty));
            _generators.Add(((cmdlet) => cmdlet.Verb == "New" && cmdlet.Noun != "Credential", GeneratePassthruProperty));
            _generators.Add(((cmdlet) => cmdlet.Verb == "Set", GeneratePassthruProperty));
            _generators.Add(((cmdlet) => cmdlet.Verb == "Connect", GeneratePassthruProperty));

            // Context-dependent properties
            _generators.Add(((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Team, GenerateTeamScopeProperty));
            _generators.Add(((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Project, GenerateProjectScopeProperty));
            _generators.Add(((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Collection, GenerateCollectionScopeProperty));
            _generators.Add(((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Server, GenerateServerScopeProperty));

            // Credential properties
            _generators.Add(((cmdlet) => cmdlet.Verb == "Connect", GenerateCredentialProperties));
            _generators.Add(((cmdlet) => IsGetScopeCmdlet(cmdlet), GenerateCredentialProperties));
            _generators.Add(((cmdlet) => cmdlet.CmdletName == "NewCredential", GenerateCredentialProperties));
        }

        private string GenerateCmdletAttribute(CmdletInfo cmdlet)
        {
            var props = new List<string>();

            if(cmdlet.SupportsShouldProcess) props.Add($"SupportsShouldProcess = true");
            if(!string.IsNullOrEmpty(cmdlet.DefaultParameterSetName)) props.Add($"DefaultParameterSetName = \"{cmdlet.DefaultParameterSetName}\"");

            return $"[Cmdlet(\"{cmdlet.Verb}\", \"Tfs{cmdlet.Noun}\"{(props.Any() ? $", {string.Join(", ", props)}" : string.Empty)})]";
        }

        private string GenerateOutputTypeAttribute(CmdletInfo cmdlet)
        {
            if(cmdlet.OutputType == null && cmdlet.DataType == null) return string.Empty;

            return cmdlet.OutputType != null ? 
                $"\n  [OutputType(typeof({cmdlet.OutputType.FullName()}))]" :
                $"\n  [OutputType(typeof({cmdlet.DataType.FullName()}))]";
        }

        private static string GenerateNewNameProperty(CmdletInfo settings) => @"
        /// <summary>
        /// HELP_PARAM_NEWNAME
        /// </summary>
        [Parameter(Position = 1, Mandatory = true)]
        public string NewName { get; set; }
";

        private static string GeneratePassthruProperty(CmdletInfo settings) => @"
        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter]
        public SwitchParameter Passthru { get; set; }
";

        private string GenerateTeamScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Team, settings);

        private string GenerateProjectScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Project, settings);

        private string GenerateCollectionScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Collection, settings);

        private string GenerateServerScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Server, settings);

        private string GenerateCredentialProperties(CmdletInfo settings) => @"
        /// <summary>
        /// HELP_PARAM_CACHED_CREDENTIAL
        /// </summary>
        [Parameter(ParameterSetName = ""Cached credentials"", Mandatory = true)]
        public SwitchParameter Cached { get; set; }

        /// <summary>
        /// HELP_PARAM_USER_NAME
        /// </summary>
        [Parameter(ParameterSetName = ""User name and password"", Mandatory = true)]
        public string UserName { get; set; }

        /// <summary>
        /// HELP_PARAM_PASSWORD
        /// </summary>
        [Parameter(ParameterSetName = ""User name and password"", Mandatory = true)]
        public SecureString Password { get; set; }

        /// <summary>
        /// HELP_PARAM_CREDENTIAL
        /// </summary>
        [Parameter(ParameterSetName = ""Credential object"", Mandatory = true)]
        [ValidateNotNull]
        public object Credential { get; set; }

        /// <summary>
        /// HELP_PARAM_PERSONAL_ACCESS_TOKEN
        /// </summary>
        [Parameter(ParameterSetName = ""Personal Access Token"", Mandatory = true)]
        [Alias(""Pat"")]
        public string PersonalAccessToken { get; set; }

        /// <summary>
        /// HELP_PARAM_INTERACTIVE
        /// </summary>
        [Parameter(ParameterSetName = ""Prompt for credential"")]
        public SwitchParameter Interactive { get; set; }
";


        private string GenerateScopeProperty(CmdletScope currentScope, CmdletInfo settings)
        {
            var scopeName = currentScope.ToString();
            var isGetScopedCmdlet = IsGetScopeCmdlet(settings);
            var isPipeline = IsPipelineProperty(scopeName, currentScope, settings);
            var valueFromPipeline = isPipeline ? "ValueFromPipeline=true" : string.Empty;
            var parameterSetNames = isGetScopedCmdlet ? _credentialParameterSetNames.Select(s => $"ParameterSetName=\"{s}\"") : new[] { string.Empty };
            var attributes = new StringBuilder();

            if (scopeName.Equals("Collection"))
            {
                attributes.Append($@"
        [Alias(""Organization"")]");
            }

            if (isGetScopedCmdlet)
            {
                attributes.Append($@"
        [Parameter(ParameterSetName=""{settings.DefaultParameterSetName}""{(isPipeline ? ", " : string.Empty)}{valueFromPipeline})]");
            }

            foreach (var parameterSetName in parameterSetNames)
            {
                attributes.Append($@"
        [Parameter({parameterSetName}{(isGetScopedCmdlet && isPipeline ? ", " : string.Empty)}{valueFromPipeline})]");
            }

            return $@"
        /// <summary>
        /// HELP_PARAM_{scopeName.ToUpper()}
        /// </summary>{attributes}
        public object {scopeName} {{ get; set; }}
";
        }

        private bool IsGetScopeCmdlet(CmdletInfo cmdlet)
            => _scopeNames.Contains(cmdlet.Noun) && cmdlet.Verb == "Get";


        private bool IsPipelineProperty(string propertyName, CmdletScope currentScope, CmdletInfo settings)
        {
            if (settings.NoAutoPipeline) return false;

            return ((settings.Verb.Equals("Get") || settings.Verb.StartsWith("Connect") || settings.Verb.StartsWith("Export")) && ((int)settings.Scope == (int)currentScope));
        }


        internal class CmdletSyntaxReceiver : ISyntaxContextReceiver
        {
            internal List<INamedTypeSymbol> Cmdlets { get; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                var node = context.Node;

                if (!(node is ClassDeclarationSyntax cds)) return;

                var type = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;

                if (!type.GetAttributes().Any(attr1 => attr1.AttributeClass.Name.EndsWith("CmdletAttribute"))) return;

                Cmdlets.Add(type);
            }
        }

        [Flags]
        private enum CmdletScope
        {
            None = 0,
            Server = 1,
            Collection = 2,
            Project = 3,
            Team = 4
        }

        private class CmdletInfo
        {
            public string CmdletName { get; private set; }
            public string Noun { get; private set; }
            internal string Verb { get; private set; }
            internal CmdletScope Scope { get; private set; }
            internal bool SkipAutoProperties { get; private set; }
            internal bool DesktopOnly { get; private set; }
            internal bool HostedOnly { get; private set; }
            internal int RequiresVersion { get; private set; }
            internal bool NoAutoPipeline { get; private set; }
            public string DefaultParameterSetName { get; private set; }
            public INamedTypeSymbol DataType { get; private set; }
            public INamedTypeSymbol OutputType { get; private set; }
            public bool SupportsShouldProcess { get; private set; }

            internal CmdletInfo(INamedTypeSymbol cmdlet)
            {
                CmdletName = cmdlet.Name;
                Verb = cmdlet.Name.Substring(0, FindIndex(cmdlet.Name, c => char.IsUpper(c), 1));
                Noun = cmdlet.Name.Substring(Verb.Length);
                Scope = GetAttributeConstructorValue<CmdletScope>(cmdlet, "TfsCmdletAttribute");
                SkipAutoProperties = GetAttributeNamedValue(cmdlet, "TfsCmdletAttribute", "SkipAutoProperties");
                DesktopOnly = GetAttributeNamedValue(cmdlet, "TfsCmdletAttribute", "DesktopOnly");
                HostedOnly = GetAttributeNamedValue(cmdlet, "TfsCmdletAttribute", "HostedOnly");
                RequiresVersion = GetAttributeNamedValue<int>(cmdlet, "TfsCmdletAttribute", "RequiresVersion");
                NoAutoPipeline = GetAttributeNamedValue<bool>(cmdlet, "TfsCmdletAttribute", "NoAutoPipeline");
                DefaultParameterSetName = GetAttributeNamedValue<string>(cmdlet, "CmdletAttribute", "DefaultParameterSetName");
                DataType = GetAttributeNamedValue<INamedTypeSymbol>(cmdlet, "TfsCmdletAttribute", "DataType");
                OutputType = GetAttributeNamedValue<INamedTypeSymbol>(cmdlet, "TfsCmdletAttribute", "OutputType");
                SupportsShouldProcess = GetAttributeNamedValue<bool>(cmdlet, "TfsCmdletAttribute", "SupportsShouldProcess");
                DefaultParameterSetName = GetAttributeNamedValue<string>(cmdlet, "TfsCmdletAttribute", "DefaultParameterSetName");
            }

            private T GetAttributeConstructorValue<T>(INamedTypeSymbol cmdlet, string attributeName, int argumentPosition = 0)
            {
                var attr = cmdlet
                    .GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass.Name.Equals(attributeName));

                if (attr == null) return default(T);

                var arg = attr.ConstructorArguments[argumentPosition];

                return (T)arg.Value;
            }

            private T GetAttributeNamedValue<T>(INamedTypeSymbol cmdlet, string attributeName, string argumentName)
            {
                var attr = cmdlet
                    .GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass.Name.Equals(attributeName));

                if (attr == null) return default(T);

                var arg = attr.NamedArguments.FirstOrDefault(a => a.Key.Equals(argumentName));

                return (T)(arg.Value.Value ?? default(T));
            }

            private bool GetAttributeNamedValue(INamedTypeSymbol cmdlet, string attributeName, string argumentName, bool defaultValue = false)
            {
                var attr = cmdlet
                    .GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass.Name.Equals(attributeName));

                if (attr == null) return defaultValue;

                var arg = attr.NamedArguments.FirstOrDefault(a => a.Key.Equals(argumentName));

                return (arg.Value.Value?.ToString() ?? string.Empty).Equals("True", StringComparison.OrdinalIgnoreCase);
            }

            private static int FindIndex(string input, Predicate<char> predicate, int startIndex = 0)
            {
                for (int i = startIndex; i < input.Length; i++)
                {
                    if (predicate(input[i])) return i;
                }

                return -1;
            }

        }
    }
}