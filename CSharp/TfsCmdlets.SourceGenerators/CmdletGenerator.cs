using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TfsCmdlets.SourceGenerators
{
    [Generator]
    public class CmdletGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new CmdletSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is CmdletSyntaxReceiver syntaxReceiver)) return;

            foreach (var cmdlet in syntaxReceiver.Cmdlets)
            {
                Enum.TryParse<CmdletScope>(cmdlet
                    .GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass.Name.Equals("CmdletScopeAttribute"))?
                    .ConstructorArguments[0].Value.ToString() ?? "None", out var scope);

                var props = new StringBuilder();

                props.Append(GetPropertyFor(cmdlet, CmdletScope.Team));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Project));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Collection));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Server));

                context.AddSource($"{cmdlet.FullName()}.cs", SourceText.From($@"/*
Generated by: [TfsCmdlets.SourceGenerators.CmdletGenerator]
Class name  : {cmdlet.FullName()}
Scope       : {scope}
*/

using System.CodeDom.Compiler;
using System.Composition;
using TfsCmdlets.Services;

// ReSharper disable once CheckNamespace
namespace {cmdlet.FullNamespace()}
{{
  public partial class {cmdlet.Name}: CmdletBase
  {{
{props.ToString()}
  }}
}}
",
                    Encoding.UTF8));
            }
        }

        private string GetPropertyFor(ISymbol cmdlet, CmdletScope currentScope)
        {
            Enum.TryParse<CmdletScope>(cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals("CmdletScopeAttribute"))?
                .ConstructorArguments[0].Value.ToString() ?? "None", out var cmdletScope);

            if((cmdletScope & currentScope) == CmdletScope.None) return string.Empty;

            var scopeName = currentScope.ToString();
            var isPipeline = cmdlet.Name.StartsWith("Get") && cmdletScope == currentScope;

            return $@"
        /// <summary>
        /// HELP_PARAM_{scopeName.ToUpper()}
        /// </summary>
        [Parameter(ValueFromPipeline={isPipeline})]
        public object {scopeName} {{ get; set; }}
";
        }

        private bool IsPipelineProperty(INamedTypeSymbol cmdlet, CmdletScope cmdletScope, CmdletScope currentScope)
        {
            return cmdlet.Name.StartsWith("Get") && cmdletScope == currentScope;
        }

        internal class CmdletSyntaxReceiver : ISyntaxContextReceiver
        {
            internal List<INamedTypeSymbol> Cmdlets { get; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                var node = context.Node;

                if (!(node is ClassDeclarationSyntax cds)) return;

                var type = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;

                if (!type.GetAttributes().Any(attr1 => attr1.AttributeClass.Name.Equals("CmdletAttribute"))) return;

                Cmdlets.Add(type);
            }
        }

        [Flags]
        internal enum CmdletScope
        {
            None = 0,
            Server = 1,
            Collection = 2,
            Project = 4,
            Team = 8
        }

    }
}