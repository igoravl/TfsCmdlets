using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TfsCmdlets.SourceGenerators
{
    [Generator]
    public class CmdletGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new CmdletSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is CmdletSyntaxReceiver syntaxReceiver)) return;

            foreach (var cmdlet in syntaxReceiver.Cmdlets)
            {
                var skipCodeGen = GetSkipCodeGen(cmdlet);
                var props = new StringBuilder();

                // Add verb-specific properties

                var verb = GetVerb(cmdlet);

                switch (verb)
                {
                    case "Rename":
                    {
                        props.Append(@"
        /// <summary>
        /// HELP_PARAM_NEWNAME
        /// </summary>
        [Parameter(Position = 1, Mandatory = true)]
        public string NewName { get; set; }

        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter()]
        public SwitchParameter Passthru { get; set; }
");
                        break;
                    }
                    case "New":
                    case "Set":
                    {
                        props.Append(@"
        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter()]
        public SwitchParameter Passthru { get; set; }
");
                        break;
                    }
                }

                var attr = cmdlet
                    .GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass.Name.Equals("TfsCmdletAttribute"));

                object codeGen = ((attr?.NamedArguments.Length ?? 0) > 0) ? attr?.NamedArguments[0].Value.Value: null;

                // Add scope-specific properties

                props.Append(GetPropertyFor(cmdlet, CmdletScope.Team));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Project));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Collection));
                props.Append(GetPropertyFor(cmdlet, CmdletScope.Server));

                context.AddSource($"{cmdlet.FullName()}.cs", SourceText.From($@"/*
Generated by: [TfsCmdlets.SourceGenerators.CmdletGenerator]
Class name  : {cmdlet.FullName()}
Verb        : {verb}
SkipCodeGen : {skipCodeGen}
*/

using System.Management.Automation;
using System.Composition;
using TfsCmdlets.Services;

// ReSharper disable once CheckNamespace
namespace {cmdlet.FullNamespace()}
{{
  public partial class {cmdlet.Name}: CmdletBase
  {{
{(skipCodeGen? string.Empty: props.ToString())}
  }}
}}
",
                    Encoding.UTF8));
            }
        }

        private bool GetSkipCodeGen(INamedTypeSymbol cmdlet)
        {
            var attr = cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals("TfsCmdletAttribute"));

            if(attr == null) return false;

            var skipCodeGenArg = attr?.NamedArguments.FirstOrDefault(arg => arg.Key.Equals("SkipCodeGen"));

            return (skipCodeGenArg.Value.Value.Value?.ToString() ?? string.Empty).Equals("True", StringComparison.OrdinalIgnoreCase);
        }

        private string GetVerb(INamedTypeSymbol cmdlet)
        {
            var attr = cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals("CmdletAttribute"));

            return (string) attr.ConstructorArguments[0].Value;
        }

        private string GetPropertyFor(ISymbol cmdlet, CmdletScope currentScope)
        {
            int.TryParse(cmdlet
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass.Name.Equals("TfsCmdletAttribute"))?
                .ConstructorArguments[0].Value.ToString(), out var cmdletScope);

            if(cmdletScope < (int) currentScope) return string.Empty;

            var scopeName = currentScope.ToString();
            var isPipeline = cmdlet.Name.StartsWith("Get") && cmdletScope == (int)currentScope;
            var valueFromPipeline = isPipeline ? "(ValueFromPipeline=true)" : string.Empty;

            return $@"
        /// <summary>
        /// HELP_PARAM_{scopeName.ToUpper()}
        /// </summary>
        [Parameter{valueFromPipeline}]
        public object {scopeName} {{ get; set; }}
";
        }

        private bool IsPipelineProperty(INamedTypeSymbol cmdlet, CmdletScope cmdletScope, CmdletScope currentScope)
        {
            return cmdlet.Name.StartsWith("Get") && cmdletScope == currentScope;
        }

        internal class CmdletSyntaxReceiver : ISyntaxContextReceiver
        {
            internal List<INamedTypeSymbol> Cmdlets { get; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                var node = context.Node;

                if (!(node is ClassDeclarationSyntax cds)) return;

                var type = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;

                if (!type.GetAttributes().Any(attr1 => attr1.AttributeClass.Name.Equals("CmdletAttribute"))) return;

                Cmdlets.Add(type);
            }
        }

        [Flags]
        internal enum CmdletScope
        {
            None = 0,
            Server = 1,
            Collection = 2,
            Project = 3,
            Team = 4
        }

    }
}