using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TfsCmdlets.SourceGenerators
{
    public class CmdletGenerator : IGenerator
    {
        private static readonly string[] _scopeNames = new[]{
            "ConfigurationServer", "TeamProjectCollection", "TeamProject", "Team" };
        private static readonly string[] _credentialParameterSetNames = new[]{
            "Cached credentials", "User name and password", "Credential object", "Personal Access Token", "Prompt for credential" };

        private static readonly List<(Predicate<CmdletInfo>, Func<CmdletInfo, IEnumerable<GeneratedProperty>>, string)> _generators =
            new List<(Predicate<CmdletInfo>, Func<CmdletInfo, IEnumerable<GeneratedProperty>>, string)>()
            {
                // Basic properties
                ((cmdlet) => cmdlet.Verb == "Rename", GenerateNewNameProperty, "Rename->NewName"),
                ((cmdlet) => cmdlet.Verb == "New" && cmdlet.Noun != "Credential", GeneratePassthruProperty, "New->Passthru"),
                ((cmdlet) => cmdlet.Verb == "Set", GeneratePassthruProperty, "Set->Passthru"),
                ((cmdlet) => cmdlet.Verb == "Connect", GeneratePassthruProperty, "Connect->Passthru"),
                ((cmdlet) => cmdlet.Verb == "Enable", GeneratePassthruProperty, "Enable->Passthru"),
                ((cmdlet) => cmdlet.Verb == "Disable", GeneratePassthruProperty, "Disable->Passthru"), 

                // Context-dependent properties
                ((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Team, GenerateTeamScopeProperty, "Scope->Team"),
                ((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Project, GenerateProjectScopeProperty, "Scope->Project"),
                ((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Collection, GenerateCollectionScopeProperty, "Scope->Collection"),
                ((cmdlet) => (int)cmdlet.Scope >= (int)CmdletScope.Server, GenerateServerScopeProperty, "Scope->Server"), 

                // Credential properties
                ((cmdlet) => cmdlet.Verb == "Connect", GenerateCredentialProperties, "Connect->Credential"),
                ((cmdlet) => IsGetScopeCmdlet(cmdlet), GenerateCredentialProperties, "(IsScope)->Credential"),
                ((cmdlet) => cmdlet.Name == "NewCredential", GenerateCredentialProperties, "NewCredential->Credential"), 

                // CustomController property
                ((cmdlet) => !string.IsNullOrEmpty(cmdlet.CustomControllerName), GenerateCustomControllerProperty, "CustomController"), 

                // ReturnsValue property
                ((cmdlet) => cmdlet.ReturnsValue, GenerateReturnsValueProperty, "ReturnsValue"), 

                // Areas/Iterations StructureGroup property
                ((cmdlet) => cmdlet.Name.EndsWith("Area") || cmdlet.Name.EndsWith("Iteration"), GenerateStructureGroupProperty, "(Area/Iteration)->StructureGroup"),
            };

        public void Initialize(GeneratorExecutionContext context)
        {
        }

        public GeneratorState ProcessType(GeneratorExecutionContext context, INamedTypeSymbol type)
        {
            var cmdlet = new CmdletInfo(type);

            if (cmdlet.SkipAutoProperties)
            {
                Logger.Log("- Skipping cmdlet generation due to SkipAutoPropeties == true");
                return cmdlet;
            }

            foreach (var (condition, generator, generatorName) in _generators)
            {
                if (!condition(cmdlet))
                {
                    // Logger.Log($"- N/A: '{generatorName}'");
                    continue;
                }

                // Logger.Log($"- Running generator {generatorName}");

                foreach (var prop in generator(cmdlet))
                {
                    // Logger.Log($"  - Rendering property {prop.Name}");
                    cmdlet.GeneratedProperties.Add(prop.Name, prop);
                }
            }

            return cmdlet;
        }

        public string Generate(GeneratorState state)
        {
            var cmdlet = (CmdletInfo)state;
            var props = new StringBuilder();

            foreach (var prop in cmdlet.GeneratedProperties.Values)
            {
                props.Append(prop.ToString());
            }

            return $@"/*
Generated by: [{this.GetType().FullName}]
Class name  : {cmdlet.FullName}
Verb        : {cmdlet.Verb}
Noun        : {cmdlet.Noun}
DataType    : {cmdlet.DataType.FullName()}
OutputType  : {cmdlet.OutputType.FullName()}
SkipCodeGen : {cmdlet.SkipAutoProperties}
*/

using System.Security;
using System.Management.Automation;
using System.Composition;
using TfsCmdlets.Services;

// ReSharper disable once CheckNamespace
namespace {cmdlet.Namespace}
{{
  {cmdlet.CmdletAttribute}{cmdlet.OutputTypeAttribute}
  public partial class {cmdlet.Name}: CmdletBase
  {{
{props}
  }}
}}
";
        }

        private static IEnumerable<GeneratedProperty> GenerateNewNameProperty(CmdletInfo settings)
        {
            yield return new GeneratedProperty("NewName", "string", @"
        /// <summary>
        /// HELP_PARAM_NEWNAME
        /// </summary>
        [Parameter(Position = 1, Mandatory = true)]
        public string NewName { get; set; }
");
        }

        private static IEnumerable<GeneratedProperty> GeneratePassthruProperty(CmdletInfo settings)
        {
            yield return new GeneratedProperty("Passthru", "SwitchParameter", @"
        /// <summary>
        /// HELP_PARAM_PASSTHRU
        /// </summary>
        [Parameter]
        public SwitchParameter Passthru { get; set; }
");
        }

        private static IEnumerable<GeneratedProperty> GenerateCustomControllerProperty(CmdletInfo settings)
        {
            yield return new GeneratedProperty("CommandName", "string", true, $@"
        protected override string CommandName => ""{settings.CustomControllerName}"";
");
        }

        private static IEnumerable<GeneratedProperty> GenerateReturnsValueProperty(CmdletInfo settings)
        {
            yield return new GeneratedProperty("ReturnsValue", "bool", true, $@"
        protected override bool ReturnsValue => {settings.ReturnsValue.ToString().ToLower()};
");
        }

        private static IEnumerable<GeneratedProperty> GenerateStructureGroupProperty(CmdletInfo settings)
        {
            yield return new GeneratedProperty("StructureGroup", "Microsoft.TeamFoundation.WorkItemTracking.WebApi.Models.TreeStructureGroup", $@"
        [Parameter]
        internal Microsoft.TeamFoundation.WorkItemTracking.WebApi.Models.TreeStructureGroup StructureGroup => 
            Microsoft.TeamFoundation.WorkItemTracking.WebApi.Models.TreeStructureGroup.{(settings.Name.EndsWith("Area") ? "Areas" : "Iterations")};
");
        }

        private static IEnumerable<GeneratedProperty> GenerateTeamScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Team, settings);

        private static IEnumerable<GeneratedProperty> GenerateProjectScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Project, settings);

        private static IEnumerable<GeneratedProperty> GenerateCollectionScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Collection, settings);

        private static IEnumerable<GeneratedProperty> GenerateServerScopeProperty(CmdletInfo settings)
            => GenerateScopeProperty(CmdletScope.Server, settings);

        private static IEnumerable<GeneratedProperty> GenerateScopeProperty(CmdletScope currentScope, CmdletInfo settings)
        {
            var scopeName = currentScope.ToString();
            var isGetScopedCmdlet = IsGetScopeCmdlet(settings);
            var isPipeline = IsPipelineProperty(scopeName, currentScope, settings);
            var valueFromPipeline = isPipeline ? "ValueFromPipeline=true" : string.Empty;
            var parameterSetNames = isGetScopedCmdlet ? _credentialParameterSetNames.Select(s => $"ParameterSetName=\"{s}\"") : new[] { string.Empty };
            var attributes = new StringBuilder();

            if (scopeName.Equals("Collection"))
            {
                attributes.Append($@"
        [Alias(""Organization"")]");
            }

            if (isGetScopedCmdlet)
            {
                attributes.Append($@"
        [Parameter(ParameterSetName=""{settings.DefaultParameterSetName}""{(isPipeline ? ", " : string.Empty)}{valueFromPipeline})]");
            }

            foreach (var parameterSetName in parameterSetNames)
            {
                attributes.Append($@"
        [Parameter({parameterSetName}{(isGetScopedCmdlet && isPipeline ? ", " : string.Empty)}{valueFromPipeline})]");
            }

            yield return new GeneratedProperty(scopeName, "object", $@"
        /// <summary>
        /// HELP_PARAM_{scopeName.ToUpper()}
        /// </summary>{attributes}
        public object {scopeName} {{ get; set; }}
");
        }

        private static IEnumerable<GeneratedProperty> GenerateCredentialProperties(CmdletInfo settings)
        {
            yield return new GeneratedProperty("Cached", "SwitchParameter", @"
        /// <summary>
        /// HELP_PARAM_CACHED_CREDENTIAL
        /// </summary>
        [Parameter(ParameterSetName = ""Cached credentials"", Mandatory = true)]
        public SwitchParameter Cached { get; set; }
");

            yield return new GeneratedProperty("UserName", "string", @"
        /// <summary>
        /// HELP_PARAM_USER_NAME
        /// </summary>
        [Parameter(ParameterSetName = ""User name and password"", Mandatory = true)]
        public string UserName { get; set; }
");

            yield return new GeneratedProperty("Password", "System.Security.SecureString", @"
        /// <summary>
        /// HELP_PARAM_PASSWORD
        /// </summary>
        [Parameter(ParameterSetName = ""User name and password"", Mandatory = true)]
        public SecureString Password { get; set; }
");

            yield return new GeneratedProperty("Credential", "object", @"
        /// <summary>
        /// HELP_PARAM_CREDENTIAL
        /// </summary>
        [Parameter(ParameterSetName = ""Credential object"", Mandatory = true)]
        [ValidateNotNull]
        public object Credential { get; set; }
");

            yield return new GeneratedProperty("PersonalAccessToken", "string", @"
        /// <summary>
        /// HELP_PARAM_PERSONAL_ACCESS_TOKEN
        /// </summary>
        [Parameter(ParameterSetName = ""Personal Access Token"", Mandatory = true)]
        [Alias(""Pat"")]
        public string PersonalAccessToken { get; set; }
");

            yield return new GeneratedProperty("Interactive", "SwitchParameter", @"
        /// <summary>
        /// HELP_PARAM_INTERACTIVE
        /// </summary>
        [Parameter(ParameterSetName = ""Prompt for credential"")]
        public SwitchParameter Interactive { get; set; }
");
        }

        private static bool IsGetScopeCmdlet(CmdletInfo cmdlet)
            => _scopeNames.Contains(cmdlet.Noun) && cmdlet.Verb == "Get";


        private static bool IsPipelineProperty(string propertyName, CmdletScope currentScope, CmdletInfo settings)
        {
            if (settings.NoAutoPipeline) return false;

            return ((settings.Verb.Equals("Get") || settings.Verb.StartsWith("Connect") || settings.Verb.StartsWith("Export")) && ((int)settings.Scope == (int)currentScope));
        }

        internal class CmdletSyntaxReceiver : ISyntaxContextReceiver
        {
            internal List<INamedTypeSymbol> Cmdlets { get; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                var node = context.Node;

                if (!(node is ClassDeclarationSyntax cds)) return;

                var type = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;

                if (!type.GetAttributes().Any(attr1 => attr1.AttributeClass.Name.EndsWith("CmdletAttribute"))) return;

                Cmdlets.Add(type);
            }
        }



    }
}