using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TfsCmdlets.SourceGenerators
{
    [Generator]
    public class ControllerGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ImportingConstructorSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is ImportingConstructorSyntaxReceiver syntaxReceiver)) return;

            var controllerBase = context.Compilation.GetTypeByMetadataName("TfsCmdlets.Controllers.ControllerBase");
            var controllerBaseT = context.Compilation.GetTypeByMetadataName("TfsCmdlets.Controllers.ControllerBase`1");

            foreach (var controller in syntaxReceiver.Controllers)
            {
                try
                {
                    var genericArg = GetGenericArgument(controller);
                    var isGeneric = !string.IsNullOrEmpty(genericArg);
                    var baseClass = isGeneric? controllerBaseT: controllerBase;
                    var ctorArgs = GetConstructorArguments(controller, baseClass);
                    var baseCtorArgs = GetBaseConstructorArguments(baseClass);
                    var propInit = GetPropertyInit(controller);

                    context.AddSource($"{controller.FullName()}.cs", SourceText.From($@"/*
Generated by: [TfsCmdlets.SourceGenerators.ImportingConstructorGenerator]
Class name  : {controller.FullName()}
*/

using System.CodeDom.Compiler;
using System.Composition;
using TfsCmdlets.Controllers;
using TfsCmdlets.Services;

// ReSharper disable once CheckNamespace
namespace {controller.FullNamespace()}
{{
  internal partial class {controller.Name}: ControllerBase{genericArg}
  {{
    [ImportingConstructor]
    public {controller.Name}({ctorArgs})
        : base({baseCtorArgs})
    {{
{propInit}
    }}
  }}
}}
",
                        Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
        }

        private object GetPropertyInit(INamedTypeSymbol controller)
                => string.Join("\n", GetImportedProperties(controller)
                    .Select(p => $"      {p.Name} = {p.Name[0].ToString().ToLower()}{p.Name.Substring(1)};"));

        private IEnumerable<IPropertySymbol> GetImportedProperties(INamedTypeSymbol controller)
            => controller
                .GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => p.GetAttributes().Any(
                    a => a.AttributeClass.Name.Equals("ImportAttribute")));

        private string GetConstructorArguments(INamedTypeSymbol controller, INamedTypeSymbol baseClass)
            => string.Join(", ", GetImportedProperties(controller)
                .Select(p => $"{p.Type.Name} {p.Name[0].ToString().ToLower()}{p.Name.Substring(1)}")
                .Concat(
                    baseClass.Constructors[0].Parameters
                        .Select(p => $"{p.Type.Name} {p.Name}")
                )
            );

        private string GetBaseConstructorArguments(INamedTypeSymbol baseClass)
        {
            return string.Join(", ", baseClass
                    .Constructors[0]
                    .Parameters
                    .Select(parm => parm.Name));
        }

        private string GetGenericArgument(INamedTypeSymbol controller)
        {
            var attr = controller.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name.Equals("CmdletControllerAttribute") ?? false);

            if (attr == null || attr.ConstructorArguments.Length == 0 || string.IsNullOrEmpty(attr.ConstructorArguments[0].Value.ToString())) return string.Empty;

            return $"<{attr.ConstructorArguments[0].Value}>";
        }

        internal class ImportingConstructorSyntaxReceiver : ISyntaxContextReceiver
        {
            internal INamedTypeSymbol ControllerBase { get; private set; }
            internal INamedTypeSymbol ControllerBaseT { get; private set; }
            internal List<INamedTypeSymbol> Controllers { get; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                var node = context.Node;

                if (!(node is ClassDeclarationSyntax cds)) return;

                var type = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;

                if (type.GetAttributes().Any(attr1 => attr1.AttributeClass.Name.Equals("CmdletControllerAttribute")
                //  && !type.GetAttributes().Any(attr2 => attr2.AttributeClass.Name.Equals("GeneratedCodeAttribute"))
                ))
                {
                    Controllers.Add(type);
                    return;
                }

                if (type.Name.Equals("ControllerBase"))
                {
                    if (type.IsGenericType)
                    {
                        ControllerBaseT = type;
                        return;
                    }

                    ControllerBase = type;
                }
            }
        }
    }
}